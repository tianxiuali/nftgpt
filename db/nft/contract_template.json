{
    "digital_art": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract AiNFT is ERC721 {\n    using Counters for Counters.Counter;\n    Counters.Counter private tokenIdCounter;\n\n    string public baseURI;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _baseURI\n    ) ERC721(_name, _symbol) {\n        baseURI = _baseURI;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n    function mint(address _to) public payable {\n        uint256 tokenId = tokenIdCounter.current();\n        _mint(_to, tokenId);\n        tokenIdCounter.increment();\n    }\n}",
    "learning_voucher": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract AiNFT is ERC721 {\n    using Counters for Counters.Counter;\n    Counters.Counter private tokenIdCounter;\n\n    string public baseURI;\n\n    mapping(uint256 => uint8) public levels;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _baseURI\n    ) ERC721(_name, _symbol) {\n        baseURI = _baseURI;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n    function mint(address _to) public payable {\n        uint256 tokenId = tokenIdCounter.current();\n        _mint(_to, tokenId);\n        tokenIdCounter.increment();\n    }\n\n    function updateCertificateLevel(uint256 tokenId, uint8 _level) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"LearningCertificate: caller is not owner nor approved\");\n        levels[tokenId] = _level;\n    }\n}"
}